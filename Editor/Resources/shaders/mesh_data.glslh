#ifndef MESH_DATA_GLSLH
#define MESH_DATA_GLSLH

#include "sphere.glslh"
#include "AABB.glslh"
#include "constants.glslh"

#extension GL_EXT_shader_explicit_arithmetic_types_int8     : require
#extension GL_EXT_shader_explicit_arithmetic_types_int32    : require
#extension GL_EXT_buffer_reference2                         : require
#extension GL_EXT_scalar_block_layout                       : require

layout(buffer_reference, scalar, buffer_reference_align = 1) readonly buffer MeshGeometryData {
    vec3 vertex_position;
};

layout(buffer_reference, scalar, buffer_reference_align = 1) readonly buffer MeshAttributesData {
    #if !defined(__OMNI_HAS_VERTEX_NORMAL) && !defined(__OMNI_HAS_VERTEX_TANGENT) && !defined(__OMNI_HAS_VERTEX_TEXCOORD_0) // using a trick so it compiles for other non-3D passes
        float unused;
    #else
        #ifdef __OMNI_HAS_VERTEX_NORMAL
            vec3 normal;
        #endif
        #ifdef __OMNI_HAS_VERTEX_TANGENT
            vec4 tangent;
        #endif
        #ifdef __OMNI_HAS_VERTEX_TEXCOORD_0
            vec2 uv;
        #endif
    #endif
};

layout(buffer_reference, scalar, buffer_reference_align = 1) readonly buffer MeshMeshletsData {
    uint vertex_offset;
    uint triangle_offset;
    uint vertex_count;
    uint triangle_count;
};

layout(buffer_reference, scalar, buffer_reference_align = 1) readonly buffer MeshMicroindices {
    uint8_t micro_index;
};

layout(buffer_reference, scalar, buffer_reference_align = 1) readonly buffer MeshletCullBounds {
    Sphere bounding_sphere;
    vec3 cone_apex;
    vec3 cone_axis;
    float cone_cutoff;
};

struct MeshLOD {
    Sphere bounding_sphere;
    uint32_t meshlet_count;
    MeshGeometryData vertices;
    MeshAttributesData attributes;
    MeshMeshletsData meshlets_data;
    MeshMicroindices micro_indices;
    MeshletCullBounds meshlets_cull_bounds;
};

layout(buffer_reference, scalar, buffer_reference_align = 4) readonly buffer MeshData {
    float lod_distance_multiplier;
    MeshLOD lods[OMNI_MAX_MESH_LOD_COUNT];
};

#endif