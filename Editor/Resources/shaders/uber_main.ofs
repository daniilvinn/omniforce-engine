#pragma lang : glsl
#pragma stage : task
#version 460 core

#extension GL_EXT_scalar_block_layout	: require
#extension GL_EXT_buffer_reference2		: require
#extension GL_EXT_nonuniform_qualifier	: require
#extension GL_EXT_mesh_shader			: require

#include "common.glslh" // common
#include "mesh_data.glslh" // mesh data
#include "render_object.glslh" // common render object data
#include "task_payload.glslh"
#include "frustum.glslh"

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

shared uint s_actual_num_meshlets;

layout(push_constant, scalar) uniform pc_ {
    CameraData camera_data;
    MeshData mesh_data;
    RenderObjectData render_objects_data;
} pc;

void main()
{
	uint lid = gl_LocalInvocationIndex; // lid = lane id
	
	RenderObjectData render_object_data = pc.render_objects_data[gl_DrawID];

	Transform transform = render_object_data.transform;
	MeshData root_mesh_data = pc.mesh_data[render_object_data.geometry_data_id];
	MeshLOD mesh_data = root_mesh_data.lods[render_object_data.lod];

	if(gl_GlobalInvocationID.x >= mesh_data.meshlet_count) { // check if we are out of bounds
		return;
	}

	if(lid == 0) { // init shared memory in first lane
		s_actual_num_meshlets = 0;
	}

	MeshletCullBounds cull_bounds = mesh_data.meshlets_cull_bounds[gl_GlobalInvocationID.x];

	vec4 rotation_quaternion = vec4(unpackSnorm2x16(transform.packed_rotation[0]), unpackSnorm2x16(transform.packed_rotation[1]));

	vec3 cone_apex = RotateByQuat(cull_bounds.cone_apex * transform.scale, rotation_quaternion) + transform.translation;
	vec3 cone_axis = RotateByQuat(cull_bounds.cone_axis, rotation_quaternion); 

	Sphere bounding_sphere = cull_bounds.bounding_sphere;
	bounding_sphere.center = RotateByQuat(bounding_sphere.center * transform.scale, rotation_quaternion) + transform.translation;
    bounding_sphere.radius = bounding_sphere.radius * max(max(transform.scale.x, transform.scale.y), transform.scale.z);

	// Cull
	if((dot(normalize(cone_apex - pc.camera_data.position), cone_axis) < cull_bounds.cone_cutoff) && FrustumTestBoundingSphere(pc.camera_data.frustum, bounding_sphere)) {
		uint id_index = atomicAdd(s_actual_num_meshlets, 1);
		task_payload.meshlet_ids[id_index] = gl_GlobalInvocationID.x;
	}

	// Emit mesh work groups
	if(lid == 0 && s_actual_num_meshlets != 0) {
		EmitMeshTasksEXT(s_actual_num_meshlets, 1, 1);
	}
}

#pragma stage : mesh
#version 460 core
#extension GL_EXT_mesh_shader : require
#extension GL_EXT_debug_printf : require

#include "common.glslh"
#include "render_object.glslh"
#include "mesh_data.glslh"

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;
layout(triangles, max_vertices = 64, max_primitives = 124) out;

layout(location = 0) out uint64_t out_material_bda[];

layout(push_constant, scalar) uniform pc_ {
    CameraData camera_data;
    MeshData mesh_data;
    RenderObjectData render_objects_data;
} pc;

layout(location = 1) out VertexOutput {
	vec3 position;
#ifdef __OMNI_HAS_VERTEX_TEXCOORD_0
    vec2 uv;
#endif
#ifdef __OMNI_HAS_VERTEX_NORMAL
	vec3 normal;
#endif
#ifdef __OMNI_HAS_NORMAL_MAP
	mat3 TBN;
#endif
} vertex_output[];


#include "task_payload.glslh"

void main()
{
	RenderObjectData render_object_data = pc.render_objects_data[gl_DrawID];

	MeshData root_mesh_data = pc.mesh_data[render_object_data.geometry_data_id];
	MeshLOD mesh_data = root_mesh_data.lods[render_object_data.lod];

	Transform transform = render_object_data.transform;
	vec4 rotation_quaternion = vec4(unpackSnorm2x16(transform.packed_rotation[0]), unpackSnorm2x16(transform.packed_rotation[1]));

	MeshMeshletsData meshlet_data = mesh_data.meshlets_data[task_payload.meshlet_ids[gl_WorkGroupID.x]];

	// vertices
	uint vertex_processing_iterations = (meshlet_data.vertex_count + gl_WorkGroupSize.x - 1) / gl_WorkGroupSize.x;
	for(int i = 0; i < vertex_processing_iterations; i++) {
		if((gl_LocalInvocationIndex * vertex_processing_iterations + i) >= meshlet_data.vertex_count) {
			break;
		}

		vec3 vertex = mesh_data.vertices[meshlet_data.vertex_offset + (gl_LocalInvocationIndex * vertex_processing_iterations + i)].vertex_position;
        vertex = RotateByQuat(vertex * transform.scale, rotation_quaternion) + transform.translation;
		vertex_output[gl_LocalInvocationIndex * vertex_processing_iterations + i].position = vertex;

		gl_MeshVerticesEXT[gl_LocalInvocationIndex * vertex_processing_iterations + i].gl_Position = pc.camera_data.view_proj * vec4(vertex, 1.0f);
	}

	uint index_processing_iterations = (meshlet_data.triangle_count + gl_WorkGroupSize.x - 1) / gl_WorkGroupSize.x;
	for(int i = 0; i < index_processing_iterations; i++) {
		if(gl_LocalInvocationIndex * index_processing_iterations + i >= meshlet_data.triangle_count) {
			break;
		}

		gl_PrimitiveTriangleIndicesEXT[gl_LocalInvocationIndex * index_processing_iterations + i] = uvec3(
			mesh_data.micro_indices[meshlet_data.triangle_offset + ((gl_LocalInvocationIndex * index_processing_iterations + i) * 3)].micro_index,
			mesh_data.micro_indices[meshlet_data.triangle_offset + ((gl_LocalInvocationIndex * index_processing_iterations + i) * 3 + 1)].micro_index,
			mesh_data.micro_indices[meshlet_data.triangle_offset + ((gl_LocalInvocationIndex * index_processing_iterations + i) * 3 + 2)].micro_index
		);
	}

	// attributes and material bda
	uint num_processing_attributes = 64 / gl_WorkGroupSize.x;
	for(int i = 0; i < num_processing_attributes; i++) {
		if((gl_LocalInvocationIndex * vertex_processing_iterations + i) >= meshlet_data.vertex_count) {
			break;
		}

		out_material_bda[gl_LocalInvocationIndex * num_processing_attributes + i] = render_object_data.material_bda;

	#ifdef __OMNI_HAS_VERTEX_TEXCOORD_0
		vertex_output[gl_LocalInvocationIndex * num_processing_attributes + i].uv = mesh_data.attributes[meshlet_data.vertex_offset + (gl_LocalInvocationIndex * num_processing_attributes + i)].uv;
	#endif

		// Process normals, tangents and bitangents
		vec3 normal = vec3(0.0f, 0.0f, 1.0f);
		vec3 T = vec3(1.0f, 0.0f, 0.0f);
		vec3 B = vec3(0.0f, 1.0f, 0.0f);
		vec3 N = vec3(0.0f, 0.0f, 1.0f);

	#ifdef __OMNI_HAS_VERTEX_NORMAL
		normal = mesh_data.attributes[meshlet_data.vertex_offset + (gl_LocalInvocationIndex * num_processing_attributes + i)].normal;
		N = normalize(RotateByQuat(normal, rotation_quaternion));
		vertex_output[gl_LocalInvocationIndex * num_processing_attributes + i].normal = normal;
	#endif
	#ifdef __OMNI_HAS_VERTEX_TANGENT
		vec4 tangent = mesh_data.attributes[meshlet_data.vertex_offset + (gl_LocalInvocationIndex * num_processing_attributes + i)].tangent;
		T = normalize(RotateByQuat(tangent.xyz, rotation_quaternion));
		T = normalize(T - dot(T, N) * N); // reorthogonalize
		B = cross(N, T) * tangent.w;
	#endif
	#ifdef __OMNI_HAS_NORMAL_MAP
		vertex_output[gl_LocalInvocationIndex * num_processing_attributes + i].TBN = mat3(T, B, N);
	#endif
	}

    if(gl_LocalInvocationIndex == 0) {
        SetMeshOutputsEXT(meshlet_data.vertex_count, meshlet_data.triangle_count);
    }
}

#pragma stage : fragment
#version 460 core
#extension GL_EXT_nonuniform_qualifier : require
#extension GL_EXT_debug_printf : require

#include "common.glslh"
#include "mesh_data.glslh"
#include "render_object.glslh"

layout(push_constant, scalar) uniform pc_ {
    CameraData camera_data;
    MeshData mesh_data;
    RenderObjectData render_objects_data;
} pc;

layout(location = 0) flat in uint64_t v_MaterialBDA;

layout(location = 1) in Input {
	vec3 position;
#ifdef __OMNI_HAS_VERTEX_TEXCOORD_0
    vec2 uv;
#endif
#ifdef __OMNI_HAS_VERTEX_NORMAL
	vec3 normal;
#endif
#ifdef __OMNI_HAS_NORMAL_MAP
	mat3 TBN;
#endif
} v_InputAttributes;


layout(buffer_reference, scalar, buffer_reference_align = 16) readonly buffer Material {
	#ifdef __OMNI_HAS_ALPHA_CUTOFF
        float alpha_cutoff;
    #endif
    #ifdef __OMNI_HAS_BASE_COLOR_FACTOR
        vec4 base_color_factor;
    #endif
    #ifdef __OMNI_HAS_BASE_COLOR_MAP
        uint base_color_map_index;
    #endif
    #ifdef __OMNI_HAS_METALLIC_FACTOR
        float metallic_factor;
    #endif
    #ifdef __OMNI_HAS_METALLIC_ROUGHNESS_MAP
        uint metallic_roughness_map_index;
    #endif
    #ifdef __OMNI_HAS_NORMAL_MAP
        uint normal_map_index;
    #endif
    #ifdef __OMNI_HAS_OCCLUSION_MAP
        uint occlusion_map_index;
    #endif
    #ifdef __OMNI_HAS_ROUGHNESS_FACTOR
        float roughness_factor;
    #endif
};

layout(location = 0) out vec4 out_position;
layout(location = 1) out vec4 out_color;
layout(location = 2) out vec4 out_normal;
layout(location = 3) out vec4 out_metallic_roughness_occlusion;

#ifdef __OMNI_HAS_NORMAL_MAP
	vec3 FetchNormal(uint normal_map_index) {
	#ifndef __OMNI_HAS_VERTEX_TEXCOORD_0
		return vec3(0.0f, 0.0f, 1.0f);
	#else
		vec3 normal = texture(texture_bank[normal_map_index], vec2(v_InputAttributes.uv.x, 1.0f - v_InputAttributes.uv.y)).rgb;
		return normal * 2.0 - 1.0;
	#endif
	}
#endif

void main() {
	Material material = Material(v_MaterialBDA);

	// Positions
	out_position = vec4(v_InputAttributes.position, 1.0f);

	// Base color
	vec4 color = vec4(1.0f, 0.0f, 1.0f, 1.0f);
	#ifdef __OMNI_HAS_BASE_COLOR_MAP
		color = texture(texture_bank[material.base_color_map_index], vec2(v_InputAttributes.uv.x, 1.0f - v_InputAttributes.uv.y));
		#ifdef __OMNI_HAS_ALPHA_CUTOFF // alpha masking
			if(color.a <= material.alpha_cutoff) discard;
		#endif
	#endif
    out_color = color;

	// Normal
	vec3 normal = vec3(0.0f, 0.0f, 1.0f);
	#ifdef __OMNI_HAS_VERTEX_NORMAL
		normal = v_InputAttributes.normal;
	#endif
	#ifdef __OMNI_HAS_NORMAL_MAP
		normal = normalize(v_InputAttributes.TBN * FetchNormal(material.normal_map_index));
	#endif
	out_normal = vec4(normal, 1.0f);

	// Metallic roughness occlusion
	vec3 metallic_roughness_occlusion = vec3(0.0f, 0.0f, 1.0f);
	#ifdef __OMNI_HAS_METALLIC_ROUGHNESS_MAP
		metallic_roughness_occlusion = texture(texture_bank[material.metallic_roughness_map_index], vec2(v_InputAttributes.uv.x, 1.0f - v_InputAttributes.uv.y)).xyz;
	#endif
	out_metallic_roughness_occlusion = vec4(metallic_roughness_occlusion, 1.0f);

}