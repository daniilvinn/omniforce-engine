#pragma lang : glsl
#pragma stage : vertex
#version 460 core

#include "Common.glslh"
#include "RenderObject.glslh"
#include "VisibleClustersBuffer.glslh"

layout(push_constant, scalar) uniform PushConstants {
	RenderObjectData render_objects;
	VisibleClusters visible_clusters;
} pc;

vec2 positions[] = {
    vec2( -1.0f,  -1.0f ),
	vec2(  1.0f,  -1.0f ),
	vec2(  1.0f,   1.0f ),
	vec2(  1.0f,   1.0f ),
	vec2( -1.0f,   1.0f ),
	vec2( -1.0f,  -1.0f )
};

void main() {
    gl_Position = vec4(positions[gl_VertexIndex], 0.0f, 1.0f);
}

#pragma stage : fragment
#version 460 core

#extension GL_EXT_shader_explicit_arithmetic_types_int64	: require

#include "Common.glslh"
#include "RenderObject.glslh"
#include "VisibleClustersBuffer.glslh"
#include "VisibilityBufferHelpers.glslh"

layout(push_constant, scalar) uniform PushConstants {
	RenderObjectData render_objects;
	VisibleClusters visible_clusters;
} pc;

layout(buffer_reference, scalar, buffer_reference_align = 4) restrict readonly buffer MaterialPipelineID {
	uint id;
};

void main() {
    uvec2 payload = unpack32(imageLoad(visibility_buffer, ivec2(gl_FragCoord.xy)).r); // unpack to avoid int64 operations (very slow)

	// Write NaN depth and return in case if there's no visible cluster in this area

	if(payload.g == 0u) {
		gl_FragDepth = uintBitsToFloat(0xFFFFFFFF);
		return;
	}

	// Move to 7 bits right to discard triangle id and get correct visible cluster ID
    VisibleCluster visible_cluster = pc.visible_clusters.clusters[payload.r >> 7];
	RenderObjectData instance_data = pc.render_objects[visible_cluster.instance_index];

	uint material_pipeline_id = MaterialPipelineID(instance_data.material_bda).id;

	// Compute fragment depth based on material pipeline id
	float depth = ComputeMaterialResolveFragmentDepth(material_pipeline_id);

	gl_FragDepth = depth;
}