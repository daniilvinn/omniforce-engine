#ifndef MESH_DATA_GLSLH
#define MESH_DATA_GLSLH

#ifdef __OMNI_COMPILE_SHADER_FOR_GLSL

#include <Shared/Transform.glslh>
#include <Shared/CameraData.glslh>
#include <Source/Sphere.glslh>
#include <Source/AABB.glslh>
#include <Source/BitStream.glslh>

#extension GL_EXT_shader_explicit_arithmetic_types_int8     : require
#extension GL_EXT_shader_explicit_arithmetic_types_float16  : require
#extension GL_EXT_buffer_reference2                         : require
#extension GL_EXT_scalar_block_layout                       : require

const int MESHLET_DATA_VERTEX_COUNT_BIT_OFFSET = 0;
const int MESHLET_DATA_VERTEX_COUNT_BIT_COUNT = 7;

const int MESHLET_DATA_TRIANGLE_COUNT_BIT_OFFSET = 7;
const int MESHLET_DATA_TRIANGLE_COUNT_BIT_COUNT = 8;

const int MESHLET_DATA_BITRATE_BIT_OFFSET = 15;
const int MESHLET_DATA_BITRATE_BIT_COUNT = 6;

struct MeshletLODCullData {
    Sphere sphere;
    Sphere parent_sphere;

    float error;
	float parent_error;
};

layout(buffer_reference, scalar, buffer_reference_align = 4) readonly buffer MeshAttributesData {
    #if !defined(__OMNI_HAS_VERTEX_NORMAL) && !defined(__OMNI_HAS_VERTEX_TANGENT) && !defined(__OMNI_HAS_VERTEX_TEXCOORDS) // using a trick so it compiles for other non-3D passes
        float unused;
    #else
        #ifdef __OMNI_HAS_VERTEX_NORMAL
            f16vec2 normal;
        #endif
        #ifdef __OMNI_HAS_VERTEX_TANGENT
            f16vec2 tangent;
        #endif
        #ifdef __OMNI_HAS_VERTEX_TEXCOORDS
            f16vec2 uv[__OMNI_MESH_TEXCOORD_COUNT];
        #endif
    #endif
};

layout(buffer_reference, scalar, buffer_reference_align = 4) readonly buffer MeshMeshletsData {
    uint vertex_bit_offset; // offset within a bitstream of vertex geometry data
	uint vertex_offset;     // offset within an array of vertex attribute data
	uint triangle_offset;
	uint metadata;          // 7 bits of vertex count, then 8 bits of triangle count and then 6 bits of bitrate
};

layout(buffer_reference, scalar, buffer_reference_align = 1) readonly buffer MeshMicroindices {
    uint8_t micro_index;
};

layout(buffer_reference, scalar, buffer_reference_align = 4) readonly buffer MeshletCullBounds {
    Sphere bounding_sphere;
    vec3 cone_apex;
    i8vec3 cone_axis;
    int8_t cone_cutoff;

    MeshletLODCullData lod_culling;
};

#define ExtractMeshletVertexCount(meshlet_metadata)     bitfieldExtract(meshlet_metadata, MESHLET_DATA_VERTEX_COUNT_BIT_OFFSET, MESHLET_DATA_VERTEX_COUNT_BIT_COUNT)
#define ExtractMeshletTriangleCount(meshlet_metadata)   bitfieldExtract(meshlet_metadata, MESHLET_DATA_TRIANGLE_COUNT_BIT_OFFSET, MESHLET_DATA_TRIANGLE_COUNT_BIT_COUNT)
#define ExtractMeshletBitrate(meshlet_metadata)         bitfieldExtract(meshlet_metadata, MESHLET_DATA_BITRATE_BIT_OFFSET, MESHLET_DATA_BITRATE_BIT_COUNT)

// Compute local offset of the vertex channel based on multiple variables.
// Used just for convenience
ivec3 FetchVertexFromStream(ReadOnlyBitStream stream, uint meshlet_bitrate, uint offset) {
    return ivec3(
			// Read X
			BitStreamRead(stream, meshlet_bitrate, offset),
			// Read Y
			BitStreamRead(stream, meshlet_bitrate, offset + meshlet_bitrate),
			// Read Z
			BitStreamRead(stream, meshlet_bitrate, offset + meshlet_bitrate * 2)
	);
}

bool TestMeshletVisibility(MeshletCullBounds cull_bounds, CameraData camera_data, Transform transform) {

    const float CONE_DECODE_CONSTANT = 1.0f / 127.0f;

    vec3 cone_apex = TransformPoint(cull_bounds.cone_apex, transform);
	vec3 cone_axis = RotateByQuat(vec3(cull_bounds.cone_axis) * CONE_DECODE_CONSTANT, vec4(transform.rotation));
    float cone_cutoff = float(cull_bounds.cone_cutoff) * CONE_DECODE_CONSTANT;

    Sphere bounding_sphere = cull_bounds.bounding_sphere;
    bounding_sphere.center = TransformPoint(bounding_sphere.center, transform);
    bounding_sphere.radius = bounding_sphere.radius * max(max(transform.scale.x, transform.scale.y), transform.scale.z);

    bool is_front_face = dot(normalize(cone_apex - camera_data.position), cone_axis) < cone_cutoff;
    bool is_in_frustum = FrustumTestBoundingSphere(camera_data.frustum, bounding_sphere);

    return is_front_face && is_in_frustum;
}
#endif // defined __OMNI_COMPILE_SHADER_FOR_GLSL

#ifdef __OMNI_COMPILE_SHADER_FOR_CXX

#include <Foundation/Types.h>

namespace Omni::GLSL {
    struct MeshData {

    using uint = uint32;
    using ReadOnlyBitStream = uint64;
    using MeshAttributesData = uint64;
    using MeshMeshletsData = uint64;
    using MeshMicroindices = uint64;
    using MeshletCullBounds = uint64;

#else
    layout(buffer_reference, scalar, buffer_reference_align = 4) buffer MeshData {
#endif // __OMNI_COMPILE_SHADER_FOR_CXX

    float lod_distance_multiplier;
    Sphere bounding_sphere;
    uint meshlet_count;
    int quantization_grid_size;
    ReadOnlyBitStream vertices;
    MeshAttributesData attributes;
    MeshMeshletsData meshlets_data;
    MeshMicroindices micro_indices;
    MeshletCullBounds meshlets_cull_bounds;
};

#ifdef __OMNI_COMPILE_SHADER_FOR_CXX
}
#endif // defined __OMNI_COMPILE_SHADER_FOR_CXX

#endif // defined MESH_DATA_GLSLH