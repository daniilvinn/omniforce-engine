#pragma once

import Common;
import Gen.PathTracingInput;
import Compression;
import Rendering;
import Random;
import SamplingStrategy;
import MIS;
import PathTracingCommon;

using namespace Omni;

[shader("raygeneration")]
void PathConstruction()
{
    uint PixelWhiteNoise = WhiteNoiseImage[DispatchRaysIndex().xy];
    
    uint3 PixelIndex = DispatchRaysIndex();
    uint3 ImageSize = DispatchRaysDimensions();
    uint RayID = PixelIndex.z * ImageSize.x * ImageSize.y +
                 PixelIndex.y * ImageSize.x +
                 PixelIndex.x;

    ViewData* Camera = Input.View;

    RandomNumber<PCGGenerator> Random = RandomNumber<PCGGenerator>(Input.RandomSeed + RayID + PixelWhiteNoise);

    // Update white noise image
    WhiteNoiseImage[PixelIndex.xy] = Random.Get();

    float2 SubpixelJitter = Random.GetXi<float2>(0xFF) - 0.5;
    
    // Setup primary rays
    float2 Ndc = (float2(PixelIndex.xy) + SubpixelJitter) / float2(Camera.viewport_width, Camera.viewport_height) * 2.0 - 1.0;
    Ndc.y = -Ndc.y;

    float AspectRatio = Camera.viewport_width / Camera.viewport_height;
    float ScaleY = tan(Camera.fov * 0.5);
    float ScaleX = ScaleY * AspectRatio;

    float3 RayDirViewSpace = normalize(float3(Ndc.x * ScaleX, Ndc.y * ScaleY, -1.0));
    float3 Direction = normalize(mul(transpose(Camera.view), float4(RayDirViewSpace, 0.0)).xyz);
    float3 Origin = Camera.position;

    RayPayload Payload;
    Payload.Radiance = 0.0f;
    Payload.PathThroughput = 1.0f;
    Payload.IncomingDirection = Direction;
    Payload.HitPoint = Origin;
    Payload.RandomSeed = Random.Get();
    
    // Initialize MIS data (camera ray has no BSDF PDF)
    Payload.BSDFPdf = 0.0f;

    const int NumIndirectBounces = Input.Settings.MaxBounces;

    // +2 because primary ray is not generated by bounce
    // Trace until bounce limit is reached or no surface was hit
    for (uint i = 0; i < NumIndirectBounces + 2; i++) {
        RayDesc Ray;
        Ray.Origin = Payload.HitPoint;
        Ray.Direction = Payload.IncomingDirection;
        Ray.TMin = 0.001;
        Ray.TMax = Camera.far_clip_distance;

        Payload.HitPoint = FloatMax;

        TraceRay(
            SceneTLAS,
            RAY_FLAG_NONE,
            0xFF,
            0,   
            1,   
            0,   
            Ray,
            Payload
        );

        if (IsInvalidHitPoint(Payload.HitPoint)) {
            break;
        }
    }

    // Compute final color, get history, blend and write back
    float3 FinalColor = Payload.Radiance;

    if (Input.AccumulatedFrames == 1) {
        OutputImage[PixelIndex.xy] = float4(FinalColor, 1.0f);
    } else {
        float3 History = OutputImage[PixelIndex.xy].rgb;
        OutputImage[PixelIndex.xy] = float4(lerp(History, FinalColor, 1.0f / Input.AccumulatedFrames), 1.0f);
    }
}

[shader("closesthit")]
void OpaqueHit(inout RayPayload Payload, in BuiltInTriangleIntersectionAttributes Attr)
{
    HitSurfaceInfo SurfaceInfo;
    SurfaceInfo.Gather(Payload, Attr);

    RandomNumber<PCGGenerator> Random = RandomNumber<PCGGenerator>(Payload.RandomSeed);
    float2 Xi = Random.GetXi<float2>();

    // Perform BSDF sampling
    BRDFSamplingStrategy BRDFStrategy;
    SamplingResult Result = BRDFStrategy.Sample(
        SurfaceInfo.Surface,
        normalize(-Payload.IncomingDirection),
        Xi
    );

    // Check if BSDF sampling produced a valid result
    bool TerminatePath = !(Result.PDF > 1e-8 && all(isfinite(Result.Weight)) && !IsInvalidHitPoint(Result.Direction));

    // Check if BSDF sample hits a light for MIS calculation
    if (!TerminatePath) {
        // Trace ray in BSDF direction to check for light hits
        RayDesc BSDFRay;
        BSDFRay.Origin = SurfaceInfo.Surface.Position;
        BSDFRay.Direction = Result.Direction;
        BSDFRay.TMin = 0.001f;
        BSDFRay.TMax = 1000.0f; // Large distance to catch lights
        
        const uint BSDFRayFlags = RAY_FLAG_SKIP_CLOSEST_HIT_SHADER;

        InlineRayTracer BSDFRayTracer;
        HitInfo BSDFHitInfo = BSDFRayTracer.TraceRay<BSDFRayFlags>(BSDFRay);
        
        if (BSDFHitInfo.Hit && BSDFHitInfo.SBTOffset == 1) {
            // We hit a light - calculate MIS contribution
            uint LightIndex = BSDFHitInfo.InstanceIndex; // InstanceIndex equals InstanceID for lights
            
            // Calculate NEE PDF for this direction and light
            NextEventEstimator NEEForPDF = NextEventEstimator(Input.PointLights);
            float NEEPdf = NEEForPDF.CalculateNEEPDF(SurfaceInfo.Surface.Position, Result.Direction, LightIndex);
            
            if (NEEPdf > 1e-8) {
                // Apply MIS weight for BSDF sample hitting light
                PowerHeuristic MISHeuristic;
                float BSDFMISWeight = MISHeuristic.Compute(Result.PDF, NEEPdf);
                
                // Get light and add contribution
                PointLight Light = Input.PointLights.Lights[LightIndex];
                float3 LightEmission = Light.Color * Light.Intensity;
                
                // Add BSDF light contribution with MIS weight
                Payload.Radiance += LightEmission * Payload.PathThroughput * BSDFMISWeight;
            }
        }
    }

    float3 BounceDirection = Result.Direction;

    // Validate and apply BRDF weight for path continuation
    if (!TerminatePath) {
        Payload.PathThroughput *= Result.Weight;
        Payload.RandomSeed = Random.Get();
        Payload.HitPoint = SurfaceInfo.Surface.Position + SurfaceInfo.Surface.TangentSpace.N * 0.001f;
        Payload.BSDFPdf = Result.PDF;
    } else {
        // Reset BSDF PDF if no valid sample was produced
        Payload.BSDFPdf = 0.0f;
    }

    NextEventEstimator NEE = NextEventEstimator(Input.PointLights);

    NEESamplingStrategy NEEStrategy;
    Result = NEEStrategy.Sample(
        SurfaceInfo.Surface, 
        normalize(-Payload.IncomingDirection), 
        Random.GetXi<float2>(),
        NEE
    );

    if (!IsInvalidHitPoint(Result.Direction)) {
        Payload.Radiance += Result.Weight;
    }

    // Terminate path on invalid sample
    if(TerminatePath) {
        Payload.HitPoint = FloatMax;
        Payload.PathThroughput = float3(0.0, 0.0, 0.0);
        Payload.BSDFPdf = 0.0f; // Reset BSDF PDF to disable MIS
    }

    Payload.IncomingDirection = BounceDirection;
}

[shader("closesthit")]
void PointLightHit(inout RayPayload Payload, in BuiltInTriangleIntersectionAttributes Attr) {
    // Direct light hit - calculate proper emission contribution
    uint LightIndex = InstanceID();
    
    // Get the light data using instance ID
    PointLight Light = Input.PointLights.Lights[LightIndex];
    float3 LightEmission = Light.Color * Light.Intensity;
    
    // For direct light hits, we need to apply MIS weighting if there's a valid BSDF PDF
    if (Payload.BSDFPdf > 1e-8) {
        // Calculate NEE PDF for this light direction
        NextEventEstimator NEEForMIS = NextEventEstimator(Input.PointLights);
        float NEEPdf = NEEForMIS.CalculateNEEPDF(Payload.HitPoint, Payload.IncomingDirection, LightIndex);
        
        if (NEEPdf > 1e-8) {
            // Apply MIS weight for direct light hit
            PowerHeuristic MISHeuristic;
            float MISWeight = MISHeuristic.Compute(Payload.BSDFPdf, NEEPdf);
            Payload.Radiance += LightEmission * Payload.PathThroughput * MISWeight;
        } else {
            // Fallback to no MIS if NEE PDF is invalid
            Payload.Radiance += LightEmission * Payload.PathThroughput;
        }
    } else {
        // Primary ray or no BSDF PDF - direct contribution without MIS
        Payload.Radiance += LightEmission * Payload.PathThroughput;
    }
    
    // Terminate the path by invalidating hit point
    Payload.HitPoint = FloatMax;
    Payload.PathThroughput = float3(0.0, 0.0, 0.0);
    Payload.BSDFPdf = 0.0f;
}

[shader("closesthit")]
void TranslucentHit(inout RayPayload Payload, in BuiltInTriangleIntersectionAttributes Attr) {
    HitSurfaceInfo<SurfaceDomain.Transmissive> SurfaceInfo;
    SurfaceInfo.Gather(Payload, Attr);

    RandomNumber<PCGGenerator> Random = RandomNumber<PCGGenerator>(Payload.RandomSeed);
    float2 Xi = Random.GetXi<float2>();

    // Perform BSDF sampling
    BSDFSamplingStrategy BSDFStrategy;
    SamplingResult Result = BSDFStrategy.Sample(
        SurfaceInfo.Surface,
        normalize(-Payload.IncomingDirection),
        Xi
    );

    // Check if BSDF sampling produced a valid result
    bool TerminatePath = !(Result.PDF > 1e-8 && all(isfinite(Result.Weight)) && !IsInvalidHitPoint(Result.Direction));

    // Validate and apply BRDF weight for path continuation
    if (!TerminatePath) {
        Payload.PathThroughput *= Result.Weight;
        Payload.IncomingDirection = Result.Direction;
        Payload.RandomSeed = Random.Get();
        Payload.HitPoint = SurfaceInfo.Surface.Position; // + SurfaceInfo.Surface.TangentSpace.N * 0.001f;
        Payload.BSDFPdf = Result.PDF;
    } else {
        // Reset BSDF PDF if no valid sample was produced
        Payload.BSDFPdf = 0.0f;
    }

    // Terminate path on invalid sample
    if (TerminatePath) {
        Payload.HitPoint = FloatMax;
        Payload.PathThroughput = float3(0.0, 0.0, 0.0);
        Payload.BSDFPdf = 0.0f; // Reset BSDF PDF to disable MIS
    }

}

[shader("miss")]
void Miss(inout RayPayload Payload)
{
    if (!Input.Settings.EnableSkyLight) {
        return;
    }

    float3 RayDir = WorldRayDirection();

    // Sun parameters - Dynamic based on sun elevation
    // ONLY TWEAK THIS: SunDirection.y controls time of day automatically
    // y = 1.0 = midday (bright blue sky)
    // y = 0.5 = afternoon (warm colors)  
    // y = 0.1 = sunset (orange/purple)
    // y = 0.0 = horizon (deep sunset)
    // y = -0.1 = twilight (super orange, getting dark)
    // y = -0.2+ = night (very dark, almost black)
    const float3 SunDirection = normalize(Input.Settings.SunDirection);  // Adjust Y for time of day
    const float SunAngularRadius = 0.0087;  // ~0.5 degrees (realistic sun size)
    
    // Calculate sun elevation for automatic adjustments (allow negative values for below horizon)
    float SunElevation = SunDirection.y;  // Can be negative when below horizon
    float SunElevationClamped = saturate(SunElevation);  // 0 = horizon, 1 = zenith
    
    // Dynamic turbidity based on sun elevation (lower sun = more atmospheric scattering)
    float Turbidity = lerp(8.0, 2.0, SunElevationClamped);  // 8.0 at horizon, 2.0 at zenith
    
    // Preetham sky model implementation
    float ThetaS = acos(saturate(SunDirection.y));  // Sun zenith angle
    float ThetaV = acos(saturate(RayDir.y));        // View zenith angle  
    float Gamma = acos(saturate(dot(RayDir, SunDirection))); // Angle between view and sun
    
    // Preetham coefficients for luminance distribution
    float A = -0.01925 * Turbidity - 0.25922;
    float B = -0.06651 * Turbidity + 0.00081;
    float C = -0.00041 * Turbidity + 0.21247;
    float D = -0.06409 * Turbidity - 0.89887;
    float E = -0.00325 * Turbidity + 0.04517;
    
    // Calculate zenith luminance
    float Chi = (4.0 / 9.0 - Turbidity / 120.0) * (3.14159 - 2.0 * ThetaS);
    float YZ = (4.0453 * Turbidity - 4.9710) * tan(Chi) - 0.2155 * Turbidity + 2.4192;
    YZ = max(YZ, 0.0);
    
    // Calculate luminance for current direction using Perez function
    float F_ThetaGamma = (1.0 + A * exp(B / (cos(ThetaV) + 0.01))) * 
                         (1.0 + C * exp(D * Gamma) + E * cos(Gamma) * cos(Gamma));
    float F_ThetaS_0 = (1.0 + A * exp(B / (cos(ThetaS) + 0.01))) * 
                       (1.0 + C + E);
    float Y = YZ * F_ThetaGamma / F_ThetaS_0;
    
    // Preetham coefficients for x chromaticity
    float Ax = -0.01193 * Turbidity - 0.2592;
    float Bx = -0.06297 * Turbidity + 0.0008;
    float Cx = -0.00316 * Turbidity + 0.2125;
    float Dx = -0.06496 * Turbidity - 0.8989;
    float Ex = -0.00227 * Turbidity + 0.0452;
    
    // Calculate zenith x chromaticity
    float xZ = (-0.00166 * Turbidity * Turbidity + 0.00375 * Turbidity + 0.00209) * ThetaS * ThetaS * ThetaS +
               (-0.02903 * Turbidity * Turbidity + 0.06377 * Turbidity + 0.00516) * ThetaS * ThetaS +
               (0.11693 * Turbidity * Turbidity - 0.21196 * Turbidity + 0.06052) * ThetaS + 0.25886;
    
    // Calculate x chromaticity for current direction
    float Fx_ThetaGamma = (1.0 + Ax * exp(Bx / (cos(ThetaV) + 0.01))) * 
                          (1.0 + Cx * exp(Dx * Gamma) + Ex * cos(Gamma) * cos(Gamma));
    float Fx_ThetaS_0 = (1.0 + Ax * exp(Bx / (cos(ThetaS) + 0.01))) * 
                        (1.0 + Cx + Ex);
    float x = xZ * Fx_ThetaGamma / Fx_ThetaS_0;
    
    // Preetham coefficients for y chromaticity  
    float Ay = -0.01274 * Turbidity - 0.2608;
    float By = -0.06405 * Turbidity + 0.0005;
    float Cy = -0.00322 * Turbidity + 0.2102;
    float Dy = -0.06696 * Turbidity - 0.8938;
    float Ey = -0.00153 * Turbidity + 0.0453;
    
    // Calculate zenith y chromaticity
    float yZ = (-0.00022 * Turbidity * Turbidity + 0.00823 * Turbidity + 0.00494) * ThetaS * ThetaS * ThetaS +
               (-0.04214 * Turbidity * Turbidity + 0.08970 * Turbidity - 0.04153) * ThetaS * ThetaS +
               (0.15346 * Turbidity * Turbidity - 0.26756 * Turbidity + 0.06670) * ThetaS + 0.26688;
    
    // Calculate y chromaticity for current direction
    float Fy_ThetaGamma = (1.0 + Ay * exp(By / (cos(ThetaV) + 0.01))) * 
                          (1.0 + Cy * exp(Dy * Gamma) + Ey * cos(Gamma) * cos(Gamma));
    float Fy_ThetaS_0 = (1.0 + Ay * exp(By / (cos(ThetaS) + 0.01))) * 
                        (1.0 + Cy + Ey);
    float y = yZ * Fy_ThetaGamma / Fy_ThetaS_0;
    
    // Clamp chromaticity values to valid range to prevent issues
    x = saturate(x);
    y = max(y, 0.001); // Prevent division by very small numbers
    Y = max(Y, 0.0);
    
    // Convert xyY to XYZ with safety checks
    float X = (x / y) * Y;
    float Z = ((1.0 - x - y) / y) * Y;
    
    // Clamp XYZ values to reasonable range
    X = max(X, 0.0);
    Z = max(Z, 0.0);
    
    // Convert XYZ to RGB using sRGB/Rec.709 matrix
    float3 SkyColor;
    SkyColor.r =  3.2404542 * X - 1.5371385 * Y - 0.4985314 * Z;
    SkyColor.g = -0.9692660 * X + 1.8760108 * Y + 0.0415560 * Z;
    SkyColor.b =  0.0556434 * X - 0.2040259 * Y + 1.0572252 * Z;
    
    // Debug: Let's see what the raw Preetham is giving us before conversion
    // For now, let's use a simpler approach to verify the model works
    
    // Simplified sky coloring based on angle from sun and elevation
    float SunProximity = saturate(1.0 - Gamma / 1.57); // 0-1 based on angle to sun
    float Elevation = saturate(RayDir.y); // 0-1 based on height above horizon
    
    // Dynamic sky colors based on sun elevation
    // Midday colors (high sun)
    float3 MiddayZenith = float3(0.2, 0.5, 1.0);     // Bright blue
    float3 MiddayHorizon = float3(0.7, 0.8, 1.0);    // Light blue-white
    float3 MiddaySun = float3(1.0, 1.0, 0.9);        // Bright white-yellow
    
    // Sunset colors (sun at horizon)
    float3 SunsetZenith = float3(0.3, 0.15, 0.6);    // Purple-blue
    float3 SunsetHorizon = float3(1.0, 0.4, 0.2);    // Deep orange
    float3 SunsetSun = float3(1.0, 0.8, 0.3);        // Yellow-orange
    
    // Twilight colors (sun below horizon)
    float3 TwiZenith = float3(0.05, 0.05, 0.2);      // Very dark blue
    float3 TwiHorizon = float3(0.8, 0.3, 0.1);       // Deep red-orange
    float3 TwiSun = float3(1.0, 0.6, 0.2);           // Deep orange
    
    // Night colors (sun very far below horizon)
    float3 NightZenith = float3(0.01, 0.01, 0.03);   // Almost black
    float3 NightHorizon = float3(0.02, 0.02, 0.05);  // Very dark
    float3 NightSun = float3(0.02, 0.02, 0.05);      // Very dark
    
    // Interpolate colors based on sun elevation
    float3 ZenithColor, HorizonColor, SunColor;
    
    if (SunElevation >= 0.0) {
        // Sun above horizon: interpolate between sunset and midday
        ZenithColor = lerp(SunsetZenith, MiddayZenith, SunElevationClamped);
        HorizonColor = lerp(SunsetHorizon, MiddayHorizon, SunElevationClamped);
        SunColor = lerp(SunsetSun, MiddaySun, SunElevationClamped);
    } else {
        // Sun below horizon: create twilight effect
        float TwilightBlend = saturate(-SunElevation * 6.0);  // 0 = at horizon, 1 = far below
        ZenithColor = lerp(SunsetZenith, lerp(TwiZenith, NightZenith, TwilightBlend), saturate(-SunElevation * 3.0));
        HorizonColor = lerp(SunsetHorizon, lerp(TwiHorizon, NightHorizon, TwilightBlend), saturate(-SunElevation * 2.0));
        SunColor = lerp(SunsetSun, lerp(TwiSun, NightSun, TwilightBlend), saturate(-SunElevation * 2.0));
    }
    
    // Mix colors based on elevation and sun proximity - dynamic blending
    float3 BasicSky = lerp(HorizonColor, ZenithColor, Elevation * Elevation);  // More warm colors near horizon
    SkyColor = lerp(BasicSky, SunColor, SunProximity * SunProximity * 1.2);  // Stronger sun influence
    
    // Dynamic exposure based on sun elevation
    float ExposureMultiplier;
    if (SunElevation >= 0.0) {
        ExposureMultiplier = lerp(0.4, 1.0, SunElevationClamped);  // Darker at sunset, brighter at midday
    } else {
        // Below horizon: much darker, approaching night
        float NightDarkness = saturate(-SunElevation * 8.0);  // Rapid darkening below horizon
        ExposureMultiplier = lerp(0.4, 0.05, NightDarkness);  // From sunset level to very dark
    }
    SkyColor = SkyColor * Input.Settings.SkyLightIntensity * ExposureMultiplier;
    
    // Add sun disk
    float SunAngle = acos(saturate(dot(RayDir, SunDirection)));
    float SunEdgeSoftness = 0.001;
    float SunFactor = 1.0 - smoothstep(SunAngularRadius - SunEdgeSoftness, SunAngularRadius + SunEdgeSoftness, SunAngle);
    
    // Dynamic sun disk properties based on elevation
    float3 SunDiskColor = float3(0.0, 0.0, 0.0);
    float3 SunGlowColor = float3(0.0, 0.0, 0.0);
    
    if (SunElevation >= -0.05) {  // Only show sun disk if not too far below horizon
        float SunVisibility = saturate((SunElevation + 0.05) / 0.05);  // Fade out as it goes below horizon
        
        float3 SunDiskColorBase = lerp(float3(1.0, 0.7, 0.4), float3(1.0, 1.0, 0.95), SunElevationClamped);  // Warmer at sunset
        float SunDiskIntensity = lerp(120.0, 200.0, SunElevationClamped) * SunVisibility;  // Dimmer at sunset, invisible below horizon
        SunDiskColor = SunDiskColorBase * SunDiskIntensity * SunFactor;
        
        // Dynamic sun glow based on atmospheric conditions
        float SunGlowRadius = lerp(0.12, 0.05, SunElevationClamped);  // Larger glow at sunset
        float SunGlow = exp(-SunAngle * SunAngle / (SunGlowRadius * SunGlowRadius));
        float3 SunGlowColorBase = lerp(float3(1.0, 0.6, 0.3), float3(1.0, 0.95, 0.8), SunElevationClamped);
        float SunGlowIntensity = lerp(1.5, 0.8, SunElevationClamped) * SunVisibility;  // Stronger glow at sunset, fade below horizon
        SunGlowColor = SunGlowColorBase * SunGlow * SunGlowIntensity;
    }
    
    // Combine sky color with sun
    float3 FinalColor = SkyColor + SunDiskColor + SunGlowColor;
    
    Payload.Radiance = FinalColor * Payload.PathThroughput;
}

[shader("anyhit")]
void AnyHitCheckTransparency(inout RayPayload Payload, in BuiltInTriangleIntersectionAttributes Attr) {
    InstanceRenderData Instance = Input.Instances[InstanceID()];
    GeometryMeshData Geometry = Input.Meshes[Instance.geometry_data_id];
    GeometryLayoutTable Layout = Geometry.ray_tracing.layout;
    uint3 HitTriangleIndices = Geometry.ray_tracing.indices[PrimitiveIndex()];

    float3 Barys = float3(1.0 - Attr.barycentrics.x - Attr.barycentrics.y, Attr.barycentrics);

    RTMaterial *Material = (RTMaterial *)Instance.material_address;

    // Fetch triangle positions
    float3 WorldPosition = 0;
    float4 TriangleVerticesClip[3];

    for (uint i = 0; i < 3; i++) {
        float3 Vertex = HitTriangleVertexPosition(i);

        WorldPosition += Vertex * Barys[i];
        TriangleVerticesClip[i] = mul(Input.View.view_proj, float4(Vertex, 1.0f));
    }
    WorldPosition = Instance.transform.TransformPoint(WorldPosition);

    // Calculate analytic derivatives
    float2 ImageSize;
    OutputImage.GetDimensions(ImageSize.x, ImageSize.y);

    uint3 PixelIndex = DispatchRaysIndex();

    float2 PixelNDC = (float2(PixelIndex.xy) + 0.5) / float2(Input.View.viewport_width, Input.View.viewport_height) * 2.0 - 1.0;
    PixelNDC.y = -PixelNDC.y;

    BarycentricDerivative Gradient;
    Gradient.Setup(TriangleVerticesClip[0], TriangleVerticesClip[1], TriangleVerticesClip[2], PixelNDC, ImageSize);

    // Fetch base color
    float2 UV = 0;
    float2 Ddx = 0;
    float2 Ddy = 0;

    float4 BaseColor = Material.UniformColor;
    if (Material.Metadata.HasBaseColor == 1) {
        UV = Geometry.RTFetchUV(HitTriangleIndices, Material.BaseColor.UVChannelIndex, Barys);
        Geometry.RTFetchUVGradients(HitTriangleIndices, Material.BaseColor.UVChannelIndex, Gradient, Ddx, Ddy);

        BaseColor = TextureHeap[Material.BaseColor.TextureIndex].SampleGrad(UV, Ddx, Ddy);
    }

    if (BaseColor.a < 0.5f) {
        IgnoreHit();
    }
}