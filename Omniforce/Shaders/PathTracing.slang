#pragma once

import Common;
import Gen.PathTracingInput;
import Compression;
import Rendering;
import Random;
import SamplingStrategy;

struct RayPayload
{
    float3 LightColor;
    float3 PathThroughput;
    float3 IncomingDirection;
    float3 HitPoint;
    uint RandomSeed;
};

using namespace Omni;

[shader("raygeneration")]
void PathConstruction()
{
    uint3 PixelIndex = DispatchRaysIndex();
    uint3 ImageSize = DispatchRaysDimensions();
    uint RayID = PixelIndex.z * ImageSize.x * ImageSize.y +
                 PixelIndex.y * ImageSize.x +
                 PixelIndex.x;

    ViewData* Camera = Input.View;

    RandomNumber<PCGGenerator> Random = RandomNumber<PCGGenerator>(Input.RandomSeed + RayID);
    float2 SubpixelJitter = float2(
        rcp(0xFF) * (Random.Get() & 0xFF),
        rcp(0xFF) * (Random.Get() & 0xFF)
    ) - 0.5;
    
    // Setup primary rays
    float2 Ndc = (float2(PixelIndex.xy) + SubpixelJitter) / float2(Camera.viewport_width, Camera.viewport_height) * 2.0 - 1.0;
    Ndc.y = -Ndc.y;

    float AspectRatio = Camera.viewport_width / Camera.viewport_height;
    float ScaleY = tan(Camera.fov * 0.5);
    float ScaleX = ScaleY * AspectRatio;

    float3 RayDirViewSpace = normalize(float3(Ndc.x * ScaleX, Ndc.y * ScaleY, -1.0));
    float3 Direction = normalize(mul(transpose(Camera.view), float4(RayDirViewSpace, 0.0)).xyz);
    float3 Origin = Camera.position;

    RayPayload Payload;
    Payload.LightColor = 0.0f;
    Payload.PathThroughput = 1.0f;
    Payload.IncomingDirection = Direction;
    Payload.HitPoint = Origin;

    Payload.RandomSeed = Random.Get();

    const uint NumIndirectBounces = 3;

    // +2 because primary ray is not generated by bounce
    // Trace until bounce limit is reached or no surface was hit
    for (uint i = 0; i < NumIndirectBounces + 2; i++) {
        RayDesc Ray;
        Ray.Origin = Payload.HitPoint;
        Ray.Direction = Payload.IncomingDirection;
        Ray.TMin = 0.001;
        Ray.TMax = Camera.far_clip_distance;

        Payload.HitPoint = FloatMax;

        TraceRay(
            SceneTLAS,
            RAY_FLAG_NONE,
            0xFF,
            0,   
            1,   
            0,   
            Ray,
            Payload
        );

        if (IsInvalidHitPoint(Payload.HitPoint)) {
            break;
        }
    }

    // Compute final color, get history, blend and write back
    float3 FinalColor = Payload.LightColor * Payload.PathThroughput;

    if (Input.AccumulatedFrames == 1) {
        OutputImage[PixelIndex.xy] = float4(FinalColor, 1.0f);
    } else {
        float3 History = OutputImage[PixelIndex.xy].rgb;
        OutputImage[PixelIndex.xy] = float4(lerp(History, FinalColor, 1.0f / Input.AccumulatedFrames), 1.0f);
    }
}

[shader("closesthit")]
void PathVertex(inout RayPayload Payload, in BuiltInTriangleIntersectionAttributes Attr)
{
    InstanceRenderData Instance = Input.Instances[InstanceID()];
    GeometryMeshData Geometry = Input.Meshes[Instance.geometry_data_id];
    GeometryLayoutTable Layout = Geometry.ray_tracing.layout;
    uint3 HitTriangleIndices = Geometry.ray_tracing.indices[PrimitiveIndex()];

    float3 Barys = float3(1.0 - Attr.barycentrics.x - Attr.barycentrics.y, Attr.barycentrics);

    RTMaterial* Material = (RTMaterial*)Instance.material_address;

    // Fetch triangle positions
    float3 WorldPosition = 0;
    float4 TriangleVerticesClip[3];

    for (uint i = 0; i < 3; i++) {
        float3 Vertex = HitTriangleVertexPosition(i);

        WorldPosition += Vertex * Barys[i];
        TriangleVerticesClip[i] = mul(Input.View.view_proj, float4(Vertex, 1.0f));
    }
    WorldPosition = Instance.transform.TransformPoint(WorldPosition);

    uint LastFetchedUVIndex = (uint)-1;

    // Calculate analytic derivatives
    float2 ImageSize;
    OutputImage.GetDimensions(ImageSize.x, ImageSize.y);

    uint3 PixelIndex = DispatchRaysIndex();

    float2 PixelNDC = (float2(PixelIndex.xy) + 0.5) / float2(Input.View.viewport_width, Input.View.viewport_height) * 2.0 - 1.0;
    PixelNDC.y = -PixelNDC.y;

    BarycentricDerivative Gradient;
    Gradient.Setup(TriangleVerticesClip[0], TriangleVerticesClip[1], TriangleVerticesClip[2], PixelNDC, ImageSize);

    // Fetch base color
    float2 UV = 0;
    float2 Ddx = 0;
    float2 Ddy = 0;

    float3 BaseColor = Material.UniformColor.xyz;
    if (Material.Metadata.HasBaseColor == 1) {
        UV = Geometry.RTFetchUV(HitTriangleIndices, Material.BaseColor.UVChannelIndex, Barys);
        Geometry.RTFetchUVGradients(HitTriangleIndices, Material.BaseColor.UVChannelIndex, Gradient, Ddx, Ddy);

        BaseColor = TextureHeap[Material.BaseColor.TextureIndex].SampleGrad(UV, Ddx, Ddy).rgb;
        LastFetchedUVIndex = Material.BaseColor.UVChannelIndex;
    }

    // Fetch vertex colors
    if (Layout.AttributeMask.HasColor == 1) {
        VertexDecoder Decoder;

        float3 VertexColor = 0;
        for (uint i = 0; i < 3; i++) {
            uint AttrOffset = Layout.Stride * HitTriangleIndices[i];
            uint8_t4 FetchedColor = *(uint8_t4 *)(Geometry.ray_tracing.attributes + AttrOffset + Layout.Offsets.Color);
            VertexColor += Decoder.DecodeColor(FetchedColor).rgb * Barys[i];
        }
        BaseColor *= VertexColor;
    }

    // Fetch vertex normals
    float3 GeometryNormal = 0;
    float3 TrueGeometryNormal = 0;
    {
        float3 v0 = HitTriangleVertexPosition(0);
        float3 v1 = HitTriangleVertexPosition(1);
        float3 v2 = HitTriangleVertexPosition(2);

        float3 edge1 = v1 - v0;
        float3 edge2 = v2 - v0;

        TrueGeometryNormal = normalize(cross(edge1, edge2));
    }

    if (Layout.AttributeMask.HasNormals == 1) {
        VertexDecoder Decoder;

        for (uint i = 0; i < 3; i++) {
            uint AttrOffset = Layout.Stride * HitTriangleIndices[i];
            half2 FetchedNormal = *(half2 *)(Geometry.ray_tracing.attributes + AttrOffset + Layout.Offsets.Normal);
            GeometryNormal += Decoder.OctahedronDecode(FetchedNormal) * Barys[i];
        }

        if (dot(GeometryNormal, -Payload.IncomingDirection) < 0) {
            if (Material.Metadata.DoubleSided == 1) {
                GeometryNormal = -GeometryNormal;
            } else {
                NormalFixer Fixer;
                GeometryNormal = Fixer.PullNormal(GeometryNormal, Payload.IncomingDirection, TrueGeometryNormal);
            }
        }
    } else {
        GeometryNormal = TrueGeometryNormal;
    }

    // Fetch normal map
    float4 T = 0.0;
    float3 B = 0.0;
    float3 N = normalize(GeometryNormal);
    if (Material.Metadata.HasNormal == 1 && Layout.AttributeMask.HasTangents == 1) {
        // Check if corresponding UVs are loaded; reload otherwise
        if (LastFetchedUVIndex != Material.Normal.UVChannelIndex) {
            UV = Geometry.RTFetchUV(HitTriangleIndices, Material.Normal.UVChannelIndex, Barys);
            Geometry.RTFetchUVGradients(HitTriangleIndices, Material.BaseColor.UVChannelIndex, Gradient, Ddx, Ddy);
            LastFetchedUVIndex = Material.BaseColor.UVChannelIndex;
        }

        // Fetch tangents
        VertexDecoder Decoder;
        for (uint i = 0; i < 3; i++) {
            uint AttrOffset = Layout.Stride * HitTriangleIndices[i];
            half2 FetchedTangent = *(half2 *)(Geometry.ray_tracing.attributes + AttrOffset + Layout.Offsets.Tangent);
            T += Decoder.DecodeTangent(FetchedTangent) * Barys[i];
        }
        T = normalize(T);

        // Compute bitangent
        B = cross(GeometryNormal, T.xyz) * T.w;

        // Fetch normal map, decode and transform
        float3 NormalMapTexel = TextureHeap[Material.Normal.TextureIndex].SampleGrad(UV, Ddx, Ddy).rgb;
        NormalMapTexel = Decoder.DecodeNormalMap(NormalMapTexel);

        // Build TBN matrix for a normal from normal map
        float3x3 TBN = float3x3(
            T.xyz,
            B,
            GeometryNormal
        );

        N = mul(NormalMapTexel, TBN);

        NormalFixer Fixer;
        N = Fixer.PullNormal(N, Payload.IncomingDirection, GeometryNormal);

        T.xyz = normalize(T.xyz - dot(T.xyz, N) * N);
        B = cross(N, T.xyz);
    } else {
        TangentSpace TangentSpace = TangentSpace(N);
        T.xyz = TangentSpace.T;
        B = TangentSpace.B;
    }

    // Setup tangent space
    TangentSpace TangentSpace = TangentSpace(
        QuaternionRotate(float4(Instance.transform.rotation), T.xyz),
        QuaternionRotate(float4(Instance.transform.rotation), B),
        QuaternionRotate(float4(Instance.transform.rotation), N)
    );

    // Fetch metallic roughness
    float3 MetallicRoughnessOcclusion = float3(1.0f, 1.0f, 0.0f);
    if (Material.Metadata.HasMetallicRoughness == 1) {
        if (LastFetchedUVIndex != Material.MetallicRoughness.UVChannelIndex) {
            UV = Geometry.RTFetchUV(HitTriangleIndices, Material.MetallicRoughness.UVChannelIndex, Barys);
            Geometry.RTFetchUVGradients(HitTriangleIndices, Material.BaseColor.UVChannelIndex, Gradient, Ddx, Ddy);
            LastFetchedUVIndex = Material.BaseColor.UVChannelIndex;
        }

        MetallicRoughnessOcclusion = TextureHeap[Material.MetallicRoughness.TextureIndex].SampleGrad(UV, Ddx, Ddy).rgb;
    }

    // Compute BRDF
    float Metallic = MetallicRoughnessOcclusion.b;
    float Roughness = MetallicRoughnessOcclusion.g;

    float3 V = normalize(-Payload.IncomingDirection);

    float3 F0 = 0.04f;
    F0 = lerp(F0, BaseColor, Metallic);

    RandomNumber<PCGGenerator> Random = RandomNumber<PCGGenerator>(Payload.RandomSeed);
    float u1 = rcp(65535.0f) * float(Random.Get() & 0xFFFF);
    float u2 = rcp(65535.0f) * float(Random.Get() & 0xFFFF);
    float2 Xi = float2(u1, u2);

    PBRSurface Surface;
    Surface.TangentSpace = TangentSpace;
    Surface.Position = WorldPosition;
    Surface.Color = BaseColor;
    Surface.Metallic = Metallic;
    Surface.Roughness = Roughness;

    SamplingResult Result;

    BSDFSamplingStrategy BSDFStrategy;
    Result = BSDFStrategy.Sample(
        Surface,
        V,
        F0,
        Xi
    );

    // Validate and apply BRDF weight
    if (Result.PDF > 1e-8 && all(isfinite(Result.Weight)) && !IsInvalidHitPoint(Result.Direction)) {
        Payload.PathThroughput *= Result.Weight;
        Payload.IncomingDirection = Result.Direction;
        Payload.RandomSeed = Random.Get();
        Payload.HitPoint = WorldPosition + GeometryNormal * 0.001f;
    } else {
        // Terminate path on invalid sample
        Payload.HitPoint = FloatMax;
        Payload.PathThroughput = float3(0.0, 0.0, 0.0);
    }

}

[shader("closesthit")]
void PointLightHit(inout RayPayload Payload, in BuiltInTriangleIntersectionAttributes Attr) {
    PointLight Light = Input.PointLights.Lights[InstanceID()];
    Payload.LightColor = Light.Color * Light.Intensity;
}

[shader("miss")]
void Miss(inout RayPayload Payload)
{
    //return;
    if (WorldRayDirection().y >= 0.0f) {
        Payload.LightColor = float3(0.7, 0.9, 1.0) * 2;
    } else {
        Payload.LightColor = float3(0.0, 0.0, 0.0);
    } 
}

[shader("anyhit")]
void AnyHitCheckTransparency(inout RayPayload Payload, in BuiltInTriangleIntersectionAttributes Attr) {
    InstanceRenderData Instance = Input.Instances[InstanceID()];
    GeometryMeshData Geometry = Input.Meshes[Instance.geometry_data_id];
    GeometryLayoutTable Layout = Geometry.ray_tracing.layout;
    uint3 HitTriangleIndices = Geometry.ray_tracing.indices[PrimitiveIndex()];

    float3 Barys = float3(1.0 - Attr.barycentrics.x - Attr.barycentrics.y, Attr.barycentrics);

    RTMaterial *Material = (RTMaterial *)Instance.material_address;

    // Fetch triangle positions
    float3 WorldPosition = 0;
    float4 TriangleVerticesClip[3];

    for (uint i = 0; i < 3; i++) {
        float3 Vertex = HitTriangleVertexPosition(i);

        WorldPosition += Vertex * Barys[i];
        TriangleVerticesClip[i] = mul(Input.View.view_proj, float4(Vertex, 1.0f));
    }
    WorldPosition = Instance.transform.TransformPoint(WorldPosition);

    // Calculate analytic derivatives
    float2 ImageSize;
    OutputImage.GetDimensions(ImageSize.x, ImageSize.y);

    uint3 PixelIndex = DispatchRaysIndex();

    float2 PixelNDC = (float2(PixelIndex.xy) + 0.5) / float2(Input.View.viewport_width, Input.View.viewport_height) * 2.0 - 1.0;
    PixelNDC.y = -PixelNDC.y;

    BarycentricDerivative Gradient;
    Gradient.Setup(TriangleVerticesClip[0], TriangleVerticesClip[1], TriangleVerticesClip[2], PixelNDC, ImageSize);

    // Fetch base color
    float2 UV = 0;
    float2 Ddx = 0;
    float2 Ddy = 0;

    float4 BaseColor = Material.UniformColor;
    if (Material.Metadata.HasBaseColor == 1) {
        UV = Geometry.RTFetchUV(HitTriangleIndices, Material.BaseColor.UVChannelIndex, Barys);
        Geometry.RTFetchUVGradients(HitTriangleIndices, Material.BaseColor.UVChannelIndex, Gradient, Ddx, Ddy);

        BaseColor = TextureHeap[Material.BaseColor.TextureIndex].SampleGrad(UV, Ddx, Ddy);
    }

    if (BaseColor.a < 0.5f) {
        IgnoreHit();
    }
}