#pragma once

import Common;
import Gen.PathTracingInput;
import Compression;
import Rendering;
import Random;
import SamplingStrategy;
import MIS;
import PathTracingCommon;

using namespace Omni;

[shader("raygeneration")]
void PathConstruction()
{
    uint PixelWhiteNoise = WhiteNoiseImage[DispatchRaysIndex().xy];
    
    uint3 PixelIndex = DispatchRaysIndex();
    uint3 ImageSize = DispatchRaysDimensions();
    uint RayID = PixelIndex.z * ImageSize.x * ImageSize.y +
                 PixelIndex.y * ImageSize.x +
                 PixelIndex.x;

    ViewData* Camera = Input.View;

    RandomNumber<PCGGenerator> Random = RandomNumber<PCGGenerator>(Input.RandomSeed + RayID + PixelWhiteNoise);

    // Update white noise image
    WhiteNoiseImage[PixelIndex.xy] = Random.Get();

    float2 SubpixelJitter = Random.GetXi<float2>(0xFF) - 0.5;
    
    // Setup primary rays
    float2 Ndc = (float2(PixelIndex.xy) + SubpixelJitter) / float2(Camera.viewport_width, Camera.viewport_height) * 2.0 - 1.0;
    Ndc.y = -Ndc.y;

    float AspectRatio = Camera.viewport_width / Camera.viewport_height;
    float ScaleY = tan(Camera.fov * 0.5);
    float ScaleX = ScaleY * AspectRatio;

    float3 RayDirViewSpace = normalize(float3(Ndc.x * ScaleX, Ndc.y * ScaleY, -1.0));
    float3 Direction = normalize(mul(transpose(Camera.view), float4(RayDirViewSpace, 0.0)).xyz);
    float3 Origin = Camera.position;

    RayPayload Payload;
    Payload.Radiance = 0.0f;
    Payload.PathThroughput = 1.0f;
    Payload.IncomingDirection = Direction;
    Payload.HitPoint = Origin;
    Payload.RandomSeed = Random.Get();
    
    // Initialize MIS data (camera ray has no BSDF PDF)
    Payload.BSDFPdf = 0.0f;

    const int NumIndirectBounces = Input.Settings.MaxBounces;

    // +2 because primary ray is not generated by bounce
    // Trace until bounce limit is reached or no surface was hit
    for (uint i = 0; i < NumIndirectBounces + 2; i++) {
        RayDesc Ray;
        Ray.Origin = Payload.HitPoint;
        Ray.Direction = Payload.IncomingDirection;
        Ray.TMin = 0.001;
        Ray.TMax = Camera.far_clip_distance;

        Payload.HitPoint = FloatMax;

        TraceRay(
            SceneTLAS,
            RAY_FLAG_NONE,
            0xFF,
            0,   
            1,   
            0,   
            Ray,
            Payload
        );

        if (IsInvalidHitPoint(Payload.HitPoint)) {
            break;
        }
    }

    // Compute final color, get history, blend and write back
    float3 FinalColor = Payload.Radiance;

    if (Input.AccumulatedFrames == 1) {
        OutputImage[PixelIndex.xy] = float4(FinalColor, 1.0f);
    } else {
        float3 History = OutputImage[PixelIndex.xy].rgb;
        OutputImage[PixelIndex.xy] = float4(lerp(History, FinalColor, 1.0f / Input.AccumulatedFrames), 1.0f);
    }
}

[shader("closesthit")]
void OpaqueHit(inout RayPayload Payload, in BuiltInTriangleIntersectionAttributes Attr)
{
    HitSurfaceInfo SurfaceInfo;
    SurfaceInfo.Gather(Payload, Attr);

    RandomNumber<PCGGenerator> Random = RandomNumber<PCGGenerator>(Payload.RandomSeed);
    float2 Xi = Random.GetXi<float2>();

    // Perform BSDF sampling
    BRDFSamplingStrategy BRDFStrategy;
    SamplingResult Result = BRDFStrategy.Sample(
        SurfaceInfo.Surface,
        normalize(-Payload.IncomingDirection),
        Xi
    );

    // Check if BSDF sampling produced a valid result
    bool TerminatePath = !(Result.PDF > 1e-8 && all(isfinite(Result.Weight)) && !IsInvalidHitPoint(Result.Direction));

    // Check if BSDF sample hits a light for MIS calculation
    if (!TerminatePath) {
        // Trace ray in BSDF direction to check for light hits
        RayDesc BSDFRay;
        BSDFRay.Origin = SurfaceInfo.Surface.Position;
        BSDFRay.Direction = Result.Direction;
        BSDFRay.TMin = 0.001f;
        BSDFRay.TMax = 1000.0f; // Large distance to catch lights
        
        const uint BSDFRayFlags = RAY_FLAG_SKIP_CLOSEST_HIT_SHADER;

        InlineRayTracer BSDFRayTracer;
        HitInfo BSDFHitInfo = BSDFRayTracer.TraceRay<BSDFRayFlags>(BSDFRay);
        
        if (BSDFHitInfo.Hit && BSDFHitInfo.SBTOffset == 1) {
            // We hit a light - calculate MIS contribution
            uint LightIndex = BSDFHitInfo.InstanceIndex; // InstanceIndex equals InstanceID for lights
            
            // Calculate NEE PDF for this direction and light
            NextEventEstimator NEEForPDF = NextEventEstimator(Input.PointLights);
            float NEEPdf = NEEForPDF.CalculateNEEPDF(SurfaceInfo.Surface.Position, Result.Direction, LightIndex);
            
            if (NEEPdf > 1e-8) {
                // Apply MIS weight for BSDF sample hitting light
                PowerHeuristic MISHeuristic;
                float BSDFMISWeight = MISHeuristic.Compute(Result.PDF, NEEPdf);
                
                // Get light and add contribution
                PointLight Light = Input.PointLights.Lights[LightIndex];
                float3 LightEmission = Light.Color * Light.Intensity;
                
                // Add BSDF light contribution with MIS weight
                Payload.Radiance += LightEmission * Payload.PathThroughput * BSDFMISWeight;
            }
        }
    }

    float3 BounceDirection = Result.Direction;

    // Validate and apply BRDF weight for path continuation
    if (!TerminatePath) {
        Payload.PathThroughput *= Result.Weight;
        Payload.RandomSeed = Random.Get();
        Payload.HitPoint = SurfaceInfo.Surface.Position + SurfaceInfo.Surface.TangentSpace.N * 0.001f;
        Payload.BSDFPdf = Result.PDF;
    } else {
        // Reset BSDF PDF if no valid sample was produced
        Payload.BSDFPdf = 0.0f;
    }

    NextEventEstimator NEE = NextEventEstimator(Input.PointLights);

    NEESamplingStrategy NEEStrategy;
    Result = NEEStrategy.Sample(
        SurfaceInfo.Surface, 
        normalize(-Payload.IncomingDirection), 
        Random.GetXi<float2>(),
        NEE
    );

    if (!IsInvalidHitPoint(Result.Direction)) {
        Payload.Radiance += Result.Weight;
    }

    // Terminate path on invalid sample
    if(TerminatePath) {
        Payload.HitPoint = FloatMax;
        Payload.PathThroughput = float3(0.0, 0.0, 0.0);
        Payload.BSDFPdf = 0.0f; // Reset BSDF PDF to disable MIS
    }

    Payload.IncomingDirection = BounceDirection;
}

[shader("closesthit")]
void PointLightHit(inout RayPayload Payload, in BuiltInTriangleIntersectionAttributes Attr) {
    // Direct light hit - calculate proper emission contribution
    uint LightIndex = InstanceID();
    
    // Get the light data using instance ID
    PointLight Light = Input.PointLights.Lights[LightIndex];
    float3 LightEmission = Light.Color * Light.Intensity;
    
    // For direct light hits, we need to apply MIS weighting if there's a valid BSDF PDF
    if (Payload.BSDFPdf > 1e-8) {
        // Calculate NEE PDF for this light direction
        NextEventEstimator NEEForMIS = NextEventEstimator(Input.PointLights);
        float NEEPdf = NEEForMIS.CalculateNEEPDF(Payload.HitPoint, Payload.IncomingDirection, LightIndex);
        
        if (NEEPdf > 1e-8) {
            // Apply MIS weight for direct light hit
            PowerHeuristic MISHeuristic;
            float MISWeight = MISHeuristic.Compute(Payload.BSDFPdf, NEEPdf);
            Payload.Radiance += LightEmission * Payload.PathThroughput * MISWeight;
        } else {
            // Fallback to no MIS if NEE PDF is invalid
            Payload.Radiance += LightEmission * Payload.PathThroughput;
        }
    } else {
        // Primary ray or no BSDF PDF - direct contribution without MIS
        Payload.Radiance += LightEmission * Payload.PathThroughput;
    }
    
    // Terminate the path by invalidating hit point
    Payload.HitPoint = FloatMax;
    Payload.PathThroughput = float3(0.0, 0.0, 0.0);
    Payload.BSDFPdf = 0.0f;
}

[shader("closesthit")]
void TranslucentHit(inout RayPayload Payload, in BuiltInTriangleIntersectionAttributes Attr) {
    HitSurfaceInfo<SurfaceDomain.Transmissive> SurfaceInfo;
    SurfaceInfo.Gather(Payload, Attr);

    RandomNumber<PCGGenerator> Random = RandomNumber<PCGGenerator>(Payload.RandomSeed);
    float2 Xi = Random.GetXi<float2>();

    // Perform BSDF sampling
    BSDFSamplingStrategy BSDFStrategy;
    SamplingResult Result = BSDFStrategy.Sample(
        SurfaceInfo.Surface,
        normalize(-Payload.IncomingDirection),
        Xi
    );

    // Check if BSDF sampling produced a valid result
    bool TerminatePath = !(Result.PDF > 1e-8 && all(isfinite(Result.Weight)) && !IsInvalidHitPoint(Result.Direction));

    // Validate and apply BRDF weight for path continuation
    if (!TerminatePath) {
        Payload.PathThroughput *= Result.Weight;
        Payload.IncomingDirection = Result.Direction;
        Payload.RandomSeed = Random.Get();
        Payload.HitPoint = SurfaceInfo.Surface.Position; // + SurfaceInfo.Surface.TangentSpace.N * 0.001f;
        Payload.BSDFPdf = Result.PDF;
    } else {
        // Reset BSDF PDF if no valid sample was produced
        Payload.BSDFPdf = 0.0f;
    }

    // Terminate path on invalid sample
    if (TerminatePath) {
        Payload.HitPoint = FloatMax;
        Payload.PathThroughput = float3(0.0, 0.0, 0.0);
        Payload.BSDFPdf = 0.0f; // Reset BSDF PDF to disable MIS
    }

}

[shader("miss")]
void Miss(inout RayPayload Payload)
{
    if (!Input.Settings.EnableSkyLight) {
        return;
    }
    // Compute base ray direction without subpixel jitter for stable star positions
    uint3 PixelIndex = DispatchRaysIndex();
    ViewData* Camera = Input.View;
    
    // Calculate ray direction without jitter (using pixel center)
    float2 Ndc = (float2(PixelIndex.xy) + 0.5) / float2(Camera.viewport_width, Camera.viewport_height) * 2.0 - 1.0;
    Ndc.y = -Ndc.y;
    
    float AspectRatio = Camera.viewport_width / Camera.viewport_height;
    float ScaleY = tan(Camera.fov * 0.5);
    float ScaleX = ScaleY * AspectRatio;
    
    float3 BaseRayDirViewSpace = normalize(float3(Ndc.x * ScaleX, Ndc.y * ScaleY, -1.0));
    float3 BaseRayDir = normalize(mul(transpose(Camera.view), float4(BaseRayDirViewSpace, 0.0)).xyz);
    
    // Create spatial hash from stable world ray direction
    int3 RayHash = int3(
        floor(BaseRayDir.x * 1000.0),
        floor(BaseRayDir.y * 1000.0),
        floor(BaseRayDir.z * 1000.0)
    );
    
    uint StarSeed = Input.Settings.StarGenerationSeed + 
                    uint(RayHash.x + 1000) * 73856093 +
                    uint(RayHash.y + 1000) * 19349663 +
                    uint(RayHash.z + 1000) * 83492791;
    
    RandomNumber<PCGGenerator> Random = RandomNumber<PCGGenerator>(StarSeed);

    float3 RayDir = WorldRayDirection();

    // Sun parameters - Dynamic based on sun elevation
    // ONLY TWEAK THIS: SunDirection.y controls time of day automatically
    // y = 1.0 = midday (bright blue sky)
    // y = 0.5 = afternoon (warm colors)  
    // y = 0.1 = sunset (orange/purple)
    // y = 0.0 = horizon (deep sunset)
    // y = -0.1 = twilight (super orange, getting dark)
    // y = -0.2+ = night (very dark, almost black)
    const float3 SunDirection = normalize(Input.Settings.SunDirection);  // Adjust Y for time of day
    const float SunAngularRadius = 0.0087;  // ~0.5 degrees (realistic sun size)
    
    // Simplified UE5-style sky system that actually works
    float CosViewSunAngle = dot(RayDir, SunDirection);
    float CosSunZenithAngle = SunDirection.y;
    
    // Base sky colors based on sun elevation and ray direction
    float SunElevation = saturate(CosSunZenithAngle);  // 0 = horizon, 1 = zenith
    float RayElevation = saturate(RayDir.y);           // 0 = horizon, 1 = zenith
    
    // Define color palettes for different sun positions
    // Midday colors (sun high)
    float3 MiddayZenith = float3(0.3, 0.7, 1.0);      // Bright blue
    float3 MiddayHorizon = float3(0.8, 0.9, 1.0);     // Light horizon
    
    // Sunset colors (sun low)  
    float3 SunsetZenith = float3(0.4, 0.2, 0.8);      // Purple zenith
    float3 SunsetHorizon = float3(1.0, 0.6, 0.2);     // Orange horizon
    
    // Night colors (sun below horizon)
    float3 NightZenith = float3(0.01, 0.01, 0.05);    // Very dark blue
    float3 NightHorizon = float3(0.02, 0.02, 0.06);   // Slightly lighter horizon
    
    // Interpolate colors based on sun elevation
    float3 ZenithColor, HorizonColor;
    
    if (CosSunZenithAngle >= 0.0) {
        // Sun above horizon
        ZenithColor = lerp(SunsetZenith, MiddayZenith, SunElevation);
        HorizonColor = lerp(SunsetHorizon, MiddayHorizon, SunElevation);
    } else {
        // Sun below horizon - transition to night
        float NightFactor = saturate(-CosSunZenithAngle * 3.0);
        ZenithColor = lerp(SunsetZenith, NightZenith, NightFactor);
        HorizonColor = lerp(SunsetHorizon, NightHorizon, NightFactor);
    }
    
    // Base sky gradient from horizon to zenith
    float3 SkyColor = lerp(HorizonColor, ZenithColor, RayElevation * RayElevation);
    
    // Add sun influence (warmer colors around sun)
    float SunInfluence = saturate(1.0 - acos(saturate(CosViewSunAngle)) / 1.57); // 0 to 1 based on angle to sun
    SunInfluence = pow(SunInfluence, 3.0); // Sharp falloff
    
    // Sun color based on elevation
    float3 SunColor = lerp(float3(1.0, 0.7, 0.3), float3(1.0, 1.0, 0.9), SunElevation);
    SkyColor = lerp(SkyColor, SunColor, SunInfluence * 0.6);
    
    // Apply intensity and exposure  
    float ExposureMultiplier = lerp(0.3, 1.0, saturate(CosSunZenithAngle + 0.2));
    SkyColor = SkyColor * Input.Settings.SkyLightIntensity * ExposureMultiplier;
    
    // Add sun disk
    float SunAngle = acos(saturate(CosViewSunAngle));
    float SunEdgeSoftness = 0.002;
    float SunFactor = 1.0 - smoothstep(SunAngularRadius - SunEdgeSoftness, SunAngularRadius + SunEdgeSoftness, SunAngle);
    
    float3 SunDiskColor = float3(0.0, 0.0, 0.0);
    
    if (CosSunZenithAngle > 0.0) {  // Only show sun when above horizon
        // Sun intensity based on elevation (dimmer when low)
        float SunIntensity = 30.0 * lerp(0.3, 1.0, saturate(CosSunZenithAngle));
        
        // Sun color becomes warmer when low (like atmospheric filtering)
        float3 SunDiskColorBase = lerp(float3(1.0, 0.7, 0.4), float3(1.0, 1.0, 0.95), SunElevation);
        
        SunDiskColor = SunDiskColorBase * SunIntensity * SunFactor;
        
        // Add subtle sun glow
        float SunGlowRadius = lerp(0.08, 0.03, SunElevation);
        float SunGlow = exp(-SunAngle * SunAngle / (SunGlowRadius * SunGlowRadius));
        float3 SunGlowColor = SunDiskColorBase * SunGlow * 0.5;
        
        SunDiskColor += SunGlowColor;
    }
    
    // Combine sky color with sun
    float3 FinalColor = SkyColor + SunDiskColor;
    
    // Generate stars when sun is below horizon using O(1) probabilistic approach
    // Only show stars for primary rays (PathThroughput close to 1.0) to avoid stars appearing on surfaces
    if (CosSunZenithAngle < 0.0 && all(Payload.PathThroughput > 0.99)) {
        // Check if there's a star at this direction based on density
        float StarProbability = Input.Settings.StarDensity * 0.001; // Adjust multiplier for desired density
        if (Random.GetNorm() < StarProbability) {
            // Generate star properties deterministically
            float StarSize = Random.GetNorm() * 0.5 + 0.2; // 0.2 to 1.0
            float StarBrightness = Random.GetNorm() * 0.6 + 0.4; // 0.4 to 1.0
             
            // Generate star color
            float3 StarColor;
            float ColorChoice = Random.GetNorm();
            if (ColorChoice < 0.4) {
                // Blue-white stars (like Sirius)
                StarColor = float3(0.8, 0.9, 1.0);
            } else if (ColorChoice < 0.7) {
                // Yellow-white stars (like our Sun)
                StarColor = float3(1.0, 1.0, 0.8);
            } else if (ColorChoice < 0.85) {
                // Orange-red stars (like Betelgeuse)
                StarColor = float3(1.0, 0.7, 0.5);
            } else {
                // Blue stars (like Rigel)
                StarColor = float3(0.6, 0.8, 1.0);
            }
            
            // Calculate star intensity with size-based falloff for more realistic appearance
            float StarIntensity = StarBrightness * 8.0 * StarSize; // Base intensity scales with size
            
            // Add subtle twinkling using spatial hash for consistency
            float TwinklePhase = frac(sin(Random.Get() * 0.0001) * 43758.5453) * 6.28318;
            float Twinkle = 0.85 + 0.3 * sin(TwinklePhase + Input.AccumulatedFrames * 0.02);
            StarIntensity *= Twinkle;
            
            // Apply anti-aliased star rendering based on size
            float StarAngularSize = 0.001 * StarSize; // Base star size
            float PixelSize = 2.0 / min(Input.View.viewport_width, Input.View.viewport_height); // Approximate pixel size in radians
            
            // If star is smaller than a pixel, apply brightness boost to maintain visibility
            if (StarAngularSize < PixelSize) {
                StarIntensity *= (PixelSize / StarAngularSize) * 0.5; // Boost but not linearly
            }
            
            // Apply star color and intensity
            FinalColor += StarColor * StarIntensity;
        }
    }
    
    Payload.Radiance = FinalColor * Payload.PathThroughput;
}

[shader("anyhit")]
void AnyHitCheckTransparency(inout RayPayload Payload, in BuiltInTriangleIntersectionAttributes Attr) {
    InstanceRenderData Instance = Input.Instances[InstanceID()];
    GeometryMeshData Geometry = Input.Meshes[Instance.geometry_data_id];
    GeometryLayoutTable Layout = Geometry.ray_tracing.layout;
    uint3 HitTriangleIndices = Geometry.ray_tracing.indices[PrimitiveIndex()];

    float3 Barys = float3(1.0 - Attr.barycentrics.x - Attr.barycentrics.y, Attr.barycentrics);

    RTMaterial *Material = (RTMaterial *)Instance.material_address;

    // Fetch triangle positions
    float3 WorldPosition = 0;
    float4 TriangleVerticesClip[3];

    for (uint i = 0; i < 3; i++) {
        float3 Vertex = HitTriangleVertexPosition(i);

        WorldPosition += Vertex * Barys[i];
        TriangleVerticesClip[i] = mul(Input.View.view_proj, float4(Vertex, 1.0f));
    }
    WorldPosition = Instance.transform.TransformPoint(WorldPosition);

    // Calculate analytic derivatives
    float2 ImageSize;
    OutputImage.GetDimensions(ImageSize.x, ImageSize.y);

    uint3 PixelIndex = DispatchRaysIndex();

    float2 PixelNDC = (float2(PixelIndex.xy) + 0.5) / float2(Input.View.viewport_width, Input.View.viewport_height) * 2.0 - 1.0;
    PixelNDC.y = -PixelNDC.y;

    BarycentricDerivative Gradient;
    Gradient.Setup(TriangleVerticesClip[0], TriangleVerticesClip[1], TriangleVerticesClip[2], PixelNDC, ImageSize);

    // Fetch base color
    float2 UV = 0;
    float2 Ddx = 0;
    float2 Ddy = 0;

    float4 BaseColor = Material.UniformColor;
    if (Material.Metadata.HasBaseColor == 1) {
        UV = Geometry.RTFetchUV(HitTriangleIndices, Material.BaseColor.UVChannelIndex, Barys);
        Geometry.RTFetchUVGradients(HitTriangleIndices, Material.BaseColor.UVChannelIndex, Gradient, Ddx, Ddy);

        BaseColor = TextureHeap[Material.BaseColor.TextureIndex].SampleGrad(UV, Ddx, Ddy);
    }

    if (BaseColor.a < 0.5f) {
        IgnoreHit();
    }
}